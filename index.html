<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Financial Planner v2</title>
<link rel="icon" href="data:,">
<style>
:root{
  --bg:#0f172a; --panel:#111827; --muted:#9ca3af; --text:#e5e7eb; --accent:#22c55e; --accent-2:#3b82f6; --danger:#ef4444; --warn:#f59e0b;
  --card:#0b1220; --border:#1f2937;
  --header-gradient-start: rgba(0,0,0,.7);
  --header-gradient-end: rgba(0,0,0,.2);
}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0; font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; background:var(--bg); color:var(--text)}
a{color:var(--accent-2); text-decoration:none}
header{position:sticky; top:0; z-index:5; background:linear-gradient(180deg, var(--header-gradient-start), var(--header-gradient-end)); backdrop-filter: blur(6px);}  
.container{width:100%; max-width:none; margin:0 auto; padding:16px}
.row{display:flex; gap:12px; flex-wrap:wrap}
.card{background:var(--card); border:1px solid var(--border); border-radius:12px; padding:16px}
.btn{display:inline-flex; align-items:center; gap:8px; border:1px solid var(--border); background:var(--card); color:var(--text); padding:10px 14px; border-radius:10px; cursor:pointer}
.btn[disabled]{opacity:.5; cursor:not-allowed}
.btn.primary{background:var(--accent-2); border-color:transparent}
.btn.success{background:var(--accent); border-color:transparent}
.btn.danger{background:var(--danger); border-color:transparent}
.btn.warn{background:var(--warn); border-color:transparent;color:#111}
.input, select{width:100%; padding:10px 12px; border-radius:10px; border:1px solid var(--border); background:var(--card); color:var(--text)}
.label{font-size:12px; color:var(--muted); margin-bottom:6px}
h1{font-size:22px; margin:8px 0}
h2{font-size:18px; margin:8px 0}
h3{font-size:16px; margin:8px 0}
small, .muted{color:var(--muted)}
nav .tab{padding:10px 12px; border-radius:10px; cursor:pointer}
nav .tab.active{background:var(--border)}
.grid{display:grid; gap:12px}
.grid.cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}
.grid.cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}
@media (max-width:820px){ .grid.cols-3{grid-template-columns:1fr} .grid.cols-2{grid-template-columns:1fr} }
table{width:100%; border-collapse:collapse}
th,td{padding:8px 6px; border-bottom:1px dashed var(--border);}
th{color:var(--muted); font-weight:600; text-align:left}
tbody tr:hover{background:#0f1629}
.badge{display:inline-block; padding:4px 8px; border-radius:999px; border:1px solid var(--border); color:var(--muted); font-size:12px}
.kpi{display:flex; gap:8px; align-items:baseline}
.kpi b{font-size:22px}
footer{padding:24px 16px; text-align:center; color:var(--muted)}
hr{border:0;border-top:1px solid var(--border); margin:12px 0}
.toast{position:fixed; right:16px; bottom:16px; background:#101828; border:1px solid var(--border); padding:12px 14px; border-radius:10px; display:none}
.dialog{position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.5); z-index:10;}
.dialog .modal{width:min(560px,90vw); background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:16px}
.icon{width:18px; height:18px; display:inline-block; vertical-align:-3px}
.section{display:none}
.section.active{display:block}
/* chip group */
.chips{display:flex; gap:6px; flex-wrap:wrap}
.chip{padding:6px 10px; border:1px solid var(--border); border-radius:999px; cursor:pointer}
.chip.active{background:var(--border)}
/* table actions */
.actions{display:flex; gap:6px}


/* Quick Add: wider, horizontal layout */
.quick-add-card{ padding:12px }
.quick-add-grid{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:8px;
  align-items:end;
}
.quick-add-grid input,
.quick-add-grid select{ padding-top:8px; padding-bottom:8px }
.quick-add-grid .btn{ width:100%; height:40px }


/* Position the chart dialog so it sits below the header/menu on mobile.  Use a generous
   top padding to avoid overlapping the navigation bar, and account for safe-area. */
#chartDlg{
  align-items:flex-start;
  padding-top: calc(80px + env(safe-area-inset-top));
  padding-left:12px;
  padding-right:12px;
  padding-bottom:12px;
}

.chart-modal-controls{ margin-top:12px; }

</style>
<style>
/* Interactive Chart Modal */
#chartDlg .modal{ width:min(980px,95vw); max-height:78vh; overflow:auto; }
.chart-toolbar{display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-bottom:8px}
.chart-toolbar .btn.small{padding:6px 10px; font-size:12px}
.chart-wrap{position:relative}
#chartInteractive{width:100%; height:360px; display:block; border:1px solid var(--border); border-radius:10px; background:var(--card)}
.chart-tooltip{
  position:absolute; pointer-events:none; padding:6px 8px; font-size:12px;
  background:rgba(17,24,39,.95); color:var(--text); border:1px solid var(--border);
  border-radius:8px; transform:translate(8px,-100%); display:none; white-space:nowrap
}
.chart-legend{font-size:12px; color:var(--muted)}
</style>

</head>
<body>
<header>
  <div class="container row" style="justify-content:space-between; align-items:center">
    <div style="display:flex; align-items:center; gap:8px">
      <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path stroke-width="2" d="M3 3h18M3 12h18M3 21h18"/></svg>
      <strong>Financial Planner <span class="badge" id="versionBadge"></span></strong>
    </div>
    <nav class="row" id="navTabs">
      <div data-target="overview" class="tab active">Overview</div>
      <div data-target="expenses" class="tab">Expenses</div>
      <div data-target="income" class="tab">Income</div>
      <div data-target="settings" class="tab">Settings</div>
    </nav>
  </div>
</header>

<main class="container">
  <!-- Overview -->
  <section id="overview" class="section active">
    

    <div class="grid cols-3">
      <div class="card">
        <div class="label">Target Date</div>
        <input id="targetDate" type="date" class="input"/>
        <div class="kpi" style="margin-top:8px"><span class="muted">Estimated Balance</span> <b id="estBalance">$0</b></div>
        <div class="chips" style="margin-top:8px">
          <div class="chip" data-range="90">3M</div>
          <div class="chip active" data-range="180">6M</div>
          <div class="chip" data-range="365">12M</div>
          <div class="chip" data-range="730">24M</div>
        </div>
      </div>
      <div class="card">
        <div class="label">Totals (next 12 months)</div>
        <div class="grid cols-2">
          <div><div class="muted">Income</div><b id="kpiIncome">$0</b></div>
          <div><div class="muted">Expenses</div><b id="kpiExpense">$0</b></div>
          <div><div class="muted">Net</div><b id="kpiNet">$0</b></div>
          <div><div class="muted">Days to Negative</div><b id="kpiDays">‚Äì</b></div>
        </div>
      </div>
      <!-- Move the overview chart here so it appears just above Quick Add in stacked/mobile layouts.  On wider screens this spans all three columns. -->
      <div class="card" style="grid-column: span 3">
        <canvas id="chart" height="120"></canvas>
      </div>
      <div class="card quick-add-card" style="grid-column: span 2">
        <div class="label">Quick Add</div>
        <div class="quick-add-grid">
          <input id="qaDesc" class="input" placeholder="Description">
          <input id="qaAmt" class="input" type="number" step="0.01" placeholder="Amount">
          <select id="qaFreq" class="input">
            <option value="once">once</option>
            <option value="weekly">weekly</option>
            <option value="monthly" selected>monthly</option>
            <option value="yearly">yearly</option>
          </select>
          <input id="qaDate" type="date" class="input">
          <button id="qaAddIncome" class="btn success">+ Income</button>
          <button id="qaAddExpense" class="btn danger">+ Expense</button>
        </div>
      </div>
    </div>
    <div class="card" style="margin-top:12px">
      <h2>Items Within Range</h2>
      <table>
        <thead><tr>
          <th>Description</th><th>Amount</th><th>Date</th><th>Frequency</th><th>Balance</th>
        </tr></thead>
        <tbody id="rangeTable"></tbody>
      </table>
    </div>
  </section>

  <!-- Expenses -->
  <section id="expenses" class="section">
    <div class="row" style="justify-content:space-between; align-items:center">
      <h2>Expenses</h2>
      <button class="btn danger" id="btnAddExpense">Add Expense</button>
    </div>
    <div id="expenseGroups"></div>
  </section>

  <!-- Income -->
  <section id="income" class="section">
    <div class="row" style="justify-content:space-between; align-items:center">
      <h2>Income</h2>
      <button class="btn success" id="btnAddIncome">Add Income</button>
    </div>
    <div id="incomeGroups"></div>
  </section>

  <!-- Settings -->
  <section id="settings" class="section">
    <div class="grid cols-2">
      <div class="card">
        <h3>Account Settings</h3>
        <div class="label">Starting Balance</div>
        <input id="startingBalance" type="number" step="0.01" class="input">
        <div class="row"><button id="btnSetBalance" class="btn primary" style="margin-top:10px">Set Balance</button></div>
        <hr>
        <div><span class="muted">Version:</span> <span id="settingsVersion"></span></div>
      </div>

      <div class="card">
        <h3>Data Management</h3>
        <div class="row">
          <button id="btnExport" class="btn">Export Data</button>
          <label class="btn"><input id="fileInput" type="file" accept=".json" style="display:none">Choose File</label>
          <button id="btnImport" class="btn primary" disabled>Import Data</button>
        </div>
        <small class="muted">Export creates a JSON backup. Import restores saved records. Back-compatible with v1 JSON.</small>
        <hr>
        <h3>Preferences</h3>
        <div class="label">Dark Mode</div>
        <select id="prefTheme" class="input">
          <option value="dark" selected>Dark</option>
          <option value="light">Light</option>
        </select>
      </div>
    </div>
  </section>
</main>

<footer>
  <div>Made for a single-file workflow. No build tools. Offline-ready.</div>
</footer>

<!-- Dialog -->

<!-- Interactive Chart Dialog -->
<div id="chartDlg" class="dialog">
  <div class="modal">
    <div class="row" style="justify-content:space-between; align-items:center">
      <h3 style="margin:0">Interactive Balance Chart</h3>
      <div class="chart-legend">Hover to inspect values.</div>
    </div>
    <!-- Modal controls: replicate target date, range selections and estimated balance -->
    <div class="chart-modal-controls" style="margin-top:12px">
      <div class="grid cols-3">
        <div>
          <div class="label">Target Date</div>
          <input id="modalTargetDate" type="date" class="input">
        </div>
        <div>
          <div class="label">Range</div>
          <div class="chips" id="modalChips">
            <div class="chip" data-range="90">3M</div>
            <div class="chip" data-range="180">6M</div>
            <div class="chip" data-range="365">12M</div>
            <div class="chip" data-range="730">24M</div>
          </div>
        </div>
        <div>
          <!-- Show the estimated balance inline without duplicating the word "Balance" -->
          <div class="label">Estimated Balance</div>
          <div class="kpi" style="margin-top:4px"><b id="modalEstBalance">$0</b></div>
        </div>
      </div>
    </div>
    <!-- Chart range label sits above the chart; removed zoom/pan/reset controls -->
    <div class="muted" id="chRangeLabel" style="margin-top:10px; text-align:right;"></div>
    <div class="chart-wrap">
      <canvas id="chartInteractive" height="480"></canvas>
      <div class="chart-tooltip" id="chartTip"></div>
    </div>
    <div class="row" style="justify-content:flex-end; margin-top:12px">
      <!-- Export button moved down next to the close button -->
      <button class="btn" id="chExport">Export PNG</button>
      <button class="btn" id="chartDlgClose">Close</button>
    </div>
  </div>
</div>


<div id="dlg" class="dialog">
  <div class="modal">
    <h3 id="dlgTitle">Add Item</h3>
    <div class="grid cols-2">
      <div>
        <div class="label">Type</div>
        <select id="fType" class="input"><option value="expense">Expense</option><option value="income">Income</option></select>
      </div>
      <div>
        <div class="label">Description</div>
        <input id="fDesc" class="input" placeholder="Description">
      </div>
      <div>
        <div class="label">Amount</div>
        <input id="fAmount" class="input" type="number" step="0.01">
      </div>
      <div>
        <div class="label">Start Date</div>
        <input id="fDate" class="input" type="date">
      </div>
      <div>
        <div class="label">End Date (optional)</div>
        <input id="fEnd" class="input" type="date">
      </div>
      <div>
        <div class="label">Frequency</div>
        <select id="fFreq" class="input">
          <option value="once">once</option>
          <option value="weekly">weekly</option>
          <option value="monthly">monthly</option>
          <option value="yearly">yearly</option>
        </select>
      </div>
    </div>
    <div class="row" style="justify-content:flex-end; margin-top:12px">
      <button id="btnCancel" class="btn">Cancel</button>
      <button id="btnSave" class="btn primary">Save</button>
    </div>
  </div>
</div>

<div id="toast" class="toast"></div>

<!-- Chart.js is normally loaded from a CDN.  In offline environments this
     will fail, so we fall back to a simple canvas renderer below if the
     Chart global isn't available. -->
<!-- We omit the external Chart.js dependency and instead rely on a
     lightweight custom renderer defined below.  This ensures the
     application remains fully functional in offline or restricted
     environments where CDN resources cannot be loaded. -->
<script>
// ---------- Utilities ----------
const $ = sel => document.querySelector(sel);
const $$ = sel => Array.from(document.querySelectorAll(sel));
const fmt = n => (n<0?'-':'') + '$' + Math.abs(n).toLocaleString(undefined,{maximumFractionDigits:2});
const todayStr = ()=> new Date().toISOString().slice(0,10);
const addDays = (d,n)=>{const x=new Date(d); x.setDate(x.getDate()+n); return x};
const clamp = (a,mi,ma)=>Math.max(mi,Math.min(ma,a));
const uuid = ()=>Math.random().toString(36).slice(2)+Date.now().toString(36);

// ---------- Store & Schema ----------
const schemaVersion = '2.0.2';
const defaults = ()=>({ 
  version: schemaVersion,
  settings: { theme:'dark' },
  startingBalance: 0,
  accounts: [{id:'acc-default', name:'Checking', type:'cash'}],
  categories: [],
  expenses: [], incomes: [],
  rules: [], goals: [],
});
function migrate(data){
  if(!data || typeof data!=='object') return defaults();
  if(!data.version){
    // v1 -> v2 migration
    const d = defaults();
    d.startingBalance = data.startingBalance||0;
    d.expenses = (data.expenses||[]).map(x=>({...x, id: x.id||uuid(), endDate: x.endDate||''}));
    d.incomes = (data.incomes||[]).map(x=>({...x, id: x.id||uuid(), endDate: x.endDate||''}));
    return d;
  }
  // future migrations here
  data.version = schemaVersion;
  return data;
}
const store = {
  key:'planner_v2',
  data: migrate(JSON.parse(localStorage.getItem('planner_v2')||'null')),
  save(){ localStorage.setItem(this.key, JSON.stringify(this.data)); publish(); },
  load(json){ this.data = migrate(json); this.save(); },
};

// ---------- Pub/Sub ----------
const listeners = new Set();
function subscribe(fn){ listeners.add(fn); return ()=>listeners.delete(fn); }
function publish(){ listeners.forEach(fn=>fn(store.data)); }

// ---------- Recurrence engine ----------
function* occurrences(item, fromDate, toDate){
  const start = new Date(item.date);
  const end   = item.endDate ? new Date(item.endDate) : null;
  let cur = new Date(start);
  const to = new Date(toDate);
  const step = (d)=>{
    switch(item.frequency){
      case 'weekly': d.setDate(d.getDate()+7); break;
      case 'monthly': d.setMonth(d.getMonth()+1); break;
      case 'yearly': d.setFullYear(d.getFullYear()+1); break;
      default: d.setDate(d.getDate()+36500); // once
    }
  };
  // move to first on/after fromDate
  while(cur < new Date(fromDate)) step(cur);
  while(cur <= to && (!end || cur <= end)){
    yield new Date(cur);
    if(item.frequency==='once') break;
    step(cur);
  }
}

// ---------- Selectors & Calculations ----------
function getHorizon(){
  const t = $('#targetDate').value || todayStr();
  return new Date(t);
}
function itemsInRange(from, to){
  const all = [];
  const push = (it, sign)=>{
    for(const dt of occurrences(it, from, to)){
      all.push({description: it.description, amount: it.amount*sign, date: dt, frequency: it.frequency});
    }
  };
  store.data.incomes.forEach(i=>push(i, +1));
  store.data.expenses.forEach(e=>push(e, -1));
  all.sort((a,b)=>a.date-b.date);
  return all;
}
function simulateBalance(toDate){
  const startBal = Number(store.data.startingBalance||0);
  const from = new Date();
  const items = itemsInRange(from, toDate);
  let bal = startBal, daysToNeg = null;
  const series = [];
  // seed today
  series.push({x: new Date(from), y: bal});
  for(const ev of items){
    bal += ev.amount;
    series.push({x: new Date(ev.date), y: bal});
    if(bal<0 && daysToNeg===null){
      daysToNeg = Math.ceil((ev.date - from)/86400000);
    }
  }
  if(series.length===1){ series.push({x: toDate, y: bal}); }
  return {series, endBalance: bal, daysToNeg, items};
}
function totalNext12m(){
  const from = new Date();
  const to = addDays(from, 365);
  let inc=0, exp=0;
  const add = (v,f)=>{
    for(const d of occurrences(v, from, to)){
      if(f==='inc') inc += v.amount;
      else exp += v.amount;
    }
  };
  store.data.incomes.forEach(v=>add(v,'inc'));
  store.data.expenses.forEach(v=>add(v,'exp'));
  return {inc, exp, net: inc-exp};
}

// ---------- Rendering ----------
let chart;

/**
 * Draw a simple line chart on the provided canvas.  This is used as a
 * fallback when the Chart.js library cannot be loaded (for example in
 * offline environments).  It expects an array of points with `.x` (Date)
 * and `.y` (number) properties.  The chart is rendered with a blue
 * line and basic axes.  If less than two points are provided the
 * function returns early.
 * @param {HTMLCanvasElement} canvas 
 * @param {Array<{x: Date, y: number}>} series
 */
function drawLineChart(canvas, series) {
  const ctx = canvas.getContext('2d');
  // resize canvas to the current element dimensions
  const width = canvas.clientWidth;
  const height = canvas.clientHeight || 120;
  canvas.width = width;
  canvas.height = height;
  ctx.clearRect(0, 0, width, height);
  if (!series || series.length < 2) return;
  // compute x and y ranges
  const xs = series.map(p => p.x.getTime());
  const ys = series.map(p => p.y);
  const minX = Math.min(...xs);
  const maxX = Math.max(...xs);
  const minY = Math.min(...ys);
  const maxY = Math.max(...ys);
  // ensure non-zero range to avoid division by zero
  const dx = maxX - minX || 1;
  const dy = maxY - minY || 1;
  const padX = 40;
  const padY = 20;
  // choose colours based on current theme
  const computed = getComputedStyle(document.documentElement);
  const lineColor = computed.getPropertyValue('--accent-2') || '#3b82f6';
  const axisColor = computed.getPropertyValue('--muted') || '#9ca3af';
  ctx.strokeStyle = axisColor.trim();
  ctx.lineWidth = 1;
  // draw axes (y axis on left, x axis at bottom)
  ctx.beginPath();
  ctx.moveTo(padX, padY);
  ctx.lineTo(padX, height - padY);
  ctx.lineTo(width - padX, height - padY);
  ctx.stroke();
  // draw zero line if within range
  if (minY < 0 && maxY > 0) {
    const zeroY = height - padY - ((0 - minY) / dy) * (height - 2 * padY);
    ctx.beginPath();
    ctx.moveTo(padX, zeroY);
    ctx.lineTo(width - padX, zeroY);
    ctx.strokeStyle = axisColor.trim();
    ctx.setLineDash([4, 4]);
    ctx.stroke();
    ctx.setLineDash([]);
  }
  // draw line
  ctx.strokeStyle = lineColor.trim();
  ctx.lineWidth = 2;
  ctx.beginPath();
  series.forEach((pt, idx) => {
    const x = padX + ((pt.x.getTime() - minX) / dx) * (width - 2 * padX);
    const y = height - padY - ((pt.y - minY) / dy) * (height - 2 * padY);
    if (idx === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  });
  ctx.stroke();
}
function renderOverview(){
  const from = new Date();
  // Determine the horizon: if a chip is active in the overview, use its range; otherwise use the manually selected target date.
  let to;
  const activeChip = document.querySelector('#overview .chip.active');
  if(activeChip) {
    const rangeDays = Number(activeChip.getAttribute('data-range') || 180);
    to = addDays(from, rangeDays);
    // sync the target date input with the chip selection
    $('#targetDate').value = to.toISOString().slice(0, 10);
  } else {
    const val = $('#targetDate').value;
    to = val ? new Date(val) : addDays(from, 180);
  }

  const { series, endBalance, daysToNeg, items } = simulateBalance(to);
  $('#estBalance').textContent = fmt(endBalance);

  const t12 = totalNext12m();
  $('#kpiIncome').textContent = fmt(t12.inc);
  $('#kpiExpense').textContent = fmt(t12.exp);
  $('#kpiNet').textContent = fmt(t12.net);
  $('#kpiDays').textContent = daysToNeg==null? '‚Äì' : daysToNeg + ' days';

  // chart
  const canvas = $('#chart');
  // Render the time series on our custom canvas renderer.  We avoid
  // external dependencies to ensure the chart works in offline
  // environments.  See drawLineChart() above for implementation details.
  drawLineChart(canvas, series);

  // Build rows with cumulative balance
  const tbody = $('#rangeTable');
  tbody.innerHTML='';
  const rows = [];
  let bal = Number(store.data.startingBalance||0);
  const fmtDate = d=>new Date(d).toISOString().slice(0,10);
  for(const ev of items){
    bal += ev.amount;
    rows.push({
      description: ev.description,
      amount: ev.amount,
      date: fmtDate(ev.date),
      frequency: ev.frequency,
      balance: bal
    });
  }
  // Apply sorting if a key is selected
  const st = sortState.overview;
  if(st.key){
    rows.sort((a,b)=>{
      let v1 = a[st.key];
      let v2 = b[st.key];
      // convert types for proper comparison
      if(st.key==='amount' || st.key==='balance'){
        v1 = Number(v1); v2 = Number(v2);
      }
      if(st.key==='date'){
        v1 = new Date(v1); v2 = new Date(v2);
      }
      // description and frequency stay as strings
      if(v1 < v2) return st.asc ? -1 : 1;
      if(v1 > v2) return st.asc ? 1 : -1;
      return 0;
    });
  }
  // Render sorted rows
  for(const row of rows){
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${row.description}</td><td>${fmt(row.amount)}</td><td>${row.date}</td><td>${row.frequency}</td><td>${fmt(row.balance)}</td>`;
    tbody.appendChild(tr);
  }
  // Attach sorting handlers to header after rendering
  attachOverviewSortHandlers();
}
function groupByFreq(list){
  const g = {once:[], weekly:[], monthly:[], yearly:[]};
  list.forEach(x=> (g[x.frequency]||g.once).push(x) );
  const order = ['once','weekly','monthly','yearly'];
  return order.map(k=>({key:k, items:g[k]}));
}
function annualize(item){
  switch(item.frequency){
    case 'weekly': return item.amount*52;
    case 'monthly': return item.amount*12;
    case 'yearly': return item.amount;
    default: return item.amount;
  }
}
function renderGroups(el, items, type){
  el.innerHTML='';
  const groups = groupByFreq(items);
  for(const group of groups){
    // Sort items within each frequency group using the current sort state (if any)
    const st = sortState[type];
    if(st && st.key){
      group.items.sort((a,b)=>compareExpense(a,b,st.key,st.asc));
    }
    const wrapper = document.createElement('div');
    const total = group.items.reduce((s,x)=>s+annualize(x),0);
    wrapper.className='card';
    wrapper.innerHTML = `<h3 style="display:flex;justify-content:space-between;align-items:center">${group.key[0].toUpperCase()+group.key.slice(1)} <span class="muted">Annual: ${fmt(total)}</span></h3>`;
    const table = document.createElement('table');
    // Remove the Frequency column header; frequency is implied by the group label
    table.innerHTML = `<thead><tr><th>Description</th><th>Amount</th><th>Start</th><th>End</th><th></th></tr></thead>`;
    const tbody = document.createElement('tbody');
    for(const it of group.items){
      const tr = document.createElement('tr');
      // Omit the frequency cell; the group indicates the frequency already
      tr.innerHTML = `
        <td>${it.description}</td>
        <td>${fmt(it.amount)}</td>
        <td>${it.date}</td>
        <td>${it.endDate||'-'}</td>
        <td class="actions">
          <button class="btn" data-act="edit" data-id="${it.id}">‚úèÔ∏è</button>
          <button class="btn" data-act="del" data-id="${it.id}">üóëÔ∏è</button>
        </td>`;
      tbody.appendChild(tr);
    }
    table.appendChild(tbody);
    // Attach sorting behavior to the header cells of this table
    addSortHandlers(table, type);
    wrapper.appendChild(table);
    el.appendChild(wrapper);
  }
  // wiring for edit/delete
  el.querySelectorAll('button[data-act]').forEach(btn=>{
    const id = btn.dataset.id;
    const act = btn.dataset.act;
    btn.onclick = ()=>{
      if(act==='edit') openDialog(type, store.data[type].find(x=>x.id===id));
      if(act==='del'){
        if(confirm('Delete this item?')){
          store.data[type]=store.data[type].filter(x=>x.id!==id);
          store.save();
        }
      }
    };
  });
}
function renderExpenses(){ renderGroups($('#expenseGroups'), store.data.expenses, 'expenses'); }
function renderIncome(){ renderGroups($('#incomeGroups'), store.data.incomes, 'incomes'); }
function renderSettings(){
  $('#startingBalance').value = store.data.startingBalance||0;
  $('#prefTheme').value = store.data.settings?.theme || 'dark';
  $('#settingsVersion').textContent = store.data.version;
  $('#versionBadge').textContent = store.data.version;
}

// ---------------- Sorting configuration and helpers ----------------
// Keep track of sorting state for each table. Each entry stores the current key and direction.
const sortState = {
  overview: { key: null, asc: true },
  expenses: { key: null, asc: true },
  incomes: { key: null, asc: true }
};

// Comparator function for expense/income items. Handles numbers, strings and dates.
function compareExpense(a, b, key, asc){
  let v1, v2;
  if(key === 'amount'){
    v1 = a.amount; v2 = b.amount;
  } else if(key === 'description'){
    v1 = (a.description || '').toLowerCase();
    v2 = (b.description || '').toLowerCase();
  } else if(key === 'date'){
    v1 = new Date(a.date || ''); v2 = new Date(b.date || '');
  } else if(key === 'end'){
    v1 = a.endDate ? new Date(a.endDate) : new Date(8640000000000000);
    v2 = b.endDate ? new Date(b.endDate) : new Date(8640000000000000);
  } else {
    v1 = a[key]; v2 = b[key];
  }
  if(v1 < v2) return asc ? -1 : 1;
  if(v1 > v2) return asc ? 1 : -1;
  return 0;
}

// Attach click handlers to expenses/incomes table headers for sorting
function addSortHandlers(table, type){
  const ths = table.querySelectorAll('thead th');
  const keyMap = ['description','amount','date','end'];
  ths.forEach((th, idx)=>{
    const key = keyMap[idx];
    if(!key) return;
    th.style.cursor = 'pointer';
    th.onclick = ()=>{
      const st = sortState[type];
      if(st.key === key){ st.asc = !st.asc; } else { st.key = key; st.asc = true; }
      store.data[type].sort((a,b)=>compareExpense(a,b,st.key,st.asc));
      store.save();
      if(type === 'expenses') renderExpenses(); else renderIncome();
    };
  });
}

// Attach click handlers to the items within range table headers for sorting
function attachOverviewSortHandlers(){
  const rangeTable = document.querySelector('#rangeTable');
  if(!rangeTable) return;
  const table = rangeTable.closest('table');
  if(!table) return;
  const ths = table.querySelectorAll('thead th');
  const keyMap = ['description','amount','date','frequency','balance'];
  ths.forEach((th, idx)=>{
    const key = keyMap[idx];
    if(!key) return;
    th.style.cursor = 'pointer';
    th.onclick = ()=>{
      const st = sortState.overview;
      if(st.key === key){ st.asc = !st.asc; } else { st.key = key; st.asc = true; }
      renderOverview();
    };
  });
}

// ---------- Dialogs ----------
let editingId=null, editingType='expenses';
function openDialog(type, item){
  editingType = type;
  $('#dlgTitle').textContent = (item?'Edit ':'Add ') + (type==='expenses'?'Expense':'Income');
  $('#fType').value = type==='expenses'?'expense':'income';
  $('#fDesc').value = item?.description || '';
  $('#fAmount').value = item?.amount || '';
  $('#fDate').value = item?.date || todayStr();
  $('#fEnd').value = item?.endDate || '';
  $('#fFreq').value = item?.frequency || 'monthly';
  editingId = item?.id || null;
  $('#dlg').style.display='flex';
  $('#fDesc').focus();
}
function closeDialog(){ $('#dlg').style.display='none'; }
$('#btnCancel').onclick = closeDialog;
$('#btnSave').onclick = ()=>{
  const type = $('#fType').value==='expense'?'expenses':'incomes';
  const obj = {
    id: editingId || uuid(),
    description: $('#fDesc').value.trim()||'Untitled',
    amount: Number($('#fAmount').value||0),
    date: $('#fDate').value||todayStr(),
    endDate: $('#fEnd').value||'',
    frequency: $('#fFreq').value
  };
  if(editingId){
    const arr = store.data[type];
    const ix = arr.findIndex(x=>x.id===editingId);
    arr[ix]=obj;
  } else {
    store.data[type].push(obj);
  }
  store.save();
  closeDialog();
};

// ---------- Events ----------
$('#navTabs').onclick = e=>{
  const t = e.target.closest('.tab'); if(!t) return;
  $$('.tab').forEach(x=>x.classList.remove('active')); t.classList.add('active');
  $$('.section').forEach(x=>x.classList.remove('active'));
  $('#'+t.dataset.target).classList.add('active');
  publish(); // trigger rerender visible section
};
$('#btnAddExpense').onclick = ()=>openDialog('expenses');
$('#btnAddIncome').onclick = ()=>openDialog('incomes');

// Quick add
$('#qaAddExpense').onclick = ()=>{
  const d=$('#qaDesc').value, a=Number($('#qaAmt').value||0), f=$('#qaFreq').value, dt=$('#qaDate').value||todayStr();
  if(!d||!a) return toast('Please enter description and amount');
  store.data.expenses.push({id:uuid(), description:d, amount:a, date:dt, endDate:'', frequency:f});
  store.save(); $('#qaDesc').value=''; $('#qaAmt').value='';
};
$('#qaAddIncome').onclick = ()=>{
  const d=$('#qaDesc').value, a=Number($('#qaAmt').value||0), f=$('#qaFreq').value, dt=$('#qaDate').value||todayStr();
  if(!d||!a) return toast('Please enter description and amount');
  store.data.incomes.push({id:uuid(), description:d, amount:a, date:dt, endDate:'', frequency:f});
  store.save(); $('#qaDesc').value=''; $('#qaAmt').value='';
};

// Chips (overview) - clicking a range chip will activate it and redraw.  Only
// operate on the chips within the overview to avoid interfering with modal chips.
document.querySelectorAll('#overview .chip').forEach(ch => {
  ch.onclick = () => {
    document.querySelectorAll('#overview .chip').forEach(x => x.classList.remove('active'));
    ch.classList.add('active');
    publish();
  };
});

// Target date manual change
$('#targetDate').onchange = ()=>{
  // align chips to custom (remove active chips only in the overview) and redraw
  document.querySelectorAll('#overview .chip.active').forEach(ch => ch.classList.remove('active'));
  publish();
};

// Settings
$('#btnSetBalance').onclick = ()=>{ store.data.startingBalance = Number($('#startingBalance').value||0); store.save(); toast('Balance updated'); };
$('#prefTheme').onchange = ()=>{ store.data.settings.theme = $('#prefTheme').value; store.save(); applyTheme(); };

// Import/Export
$('#fileInput').onchange = ()=> $('#btnImport').disabled = !$('#fileInput').files?.length;
$('#btnImport').onclick = async ()=>{
  const file = $('#fileInput').files[0]; if(!file) return;
  const text = await file.text();
  try{ const json = JSON.parse(text); store.load(json); toast('Import successful'); }
  catch{ toast('Invalid JSON'); }
};
$('#btnExport').onclick = ()=>{
  const blob = new Blob([JSON.stringify(store.data,null,2)], {type:'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'financial_data.json';
  a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
};

// ---------- Toast ----------
function toast(msg){ const t=$('#toast'); t.textContent=msg; t.style.display='block'; setTimeout(()=>t.style.display='none', 1800); }

// ---------- Theme ----------
function applyTheme(){
  const theme = store.data.settings?.theme || 'dark';
  if(theme==='light'){
    document.documentElement.style.setProperty('--bg','#f3f4f6');
    document.documentElement.style.setProperty('--panel','#ffffff');
    document.documentElement.style.setProperty('--card','#ffffff');
    document.documentElement.style.setProperty('--text','#111827');
    document.documentElement.style.setProperty('--muted','#4b5563');
    document.documentElement.style.setProperty('--border','#e5e7eb');
    document.documentElement.style.setProperty('--header-gradient-start','rgba(255,255,255,0.7)');
    document.documentElement.style.setProperty('--header-gradient-end','rgba(255,255,255,0.2)');
  } else {
    document.documentElement.style.setProperty('--bg','#0f172a');
    document.documentElement.style.setProperty('--panel','#111827');
    document.documentElement.style.setProperty('--card','#0b1220');
    document.documentElement.style.setProperty('--text','#e5e7eb');
    document.documentElement.style.setProperty('--muted','#9ca3af');
    document.documentElement.style.setProperty('--border','#1f2937');
    document.documentElement.style.setProperty('--header-gradient-start','rgba(0,0,0,0.7)');
    document.documentElement.style.setProperty('--header-gradient-end','rgba(0,0,0,0.2)');
  }
}

// ---------- Subscriptions ----------
subscribe((state)=>{
  // only render the active section to keep snappy
  if($('#overview').classList.contains('active')) renderOverview();
  if($('#expenses').classList.contains('active')) renderExpenses();
  if($('#income').classList.contains('active')) renderIncome();
  if($('#settings').classList.contains('active')) renderSettings();
});

// ---------- Init ----------
(function init(){
  // seed demo if empty (first run)
  if(!store.data.incomes.length && !store.data.expenses.length){
    const t=todayStr();
    store.data.startingBalance=1416;
    store.data.incomes=[
      {id:uuid(), description:'CME', amount:1559, date:t, frequency:'weekly', endDate:''},
      {id:uuid(), description:'RCC', amount:1152, date:t, frequency:'once', endDate:''},
      {id:uuid(), description:'PC RCF', amount:5100, date:t, frequency:'monthly', endDate:''},
    ];
    store.data.expenses=[
      {id:uuid(), description:'Grocery', amount:160, date:t, frequency:'weekly', endDate:''},
      {id:uuid(), description:'Netflix', amount:33, date:'2024-09-30', frequency:'monthly', endDate:''},
      {id:uuid(), description:'Disney+', amount:15, date:'2024-10-10', frequency:'monthly', endDate:''},
      {id:uuid(), description:'T-Mobile', amount:100, date:'2024-10-13', frequency:'monthly', endDate:''},
      {id:uuid(), description:'Mazda Buyout', amount:20000, date:'2026-08-03', frequency:'once', endDate:'2026-08-03'}
    ];
    store.save();
  } else { publish(); } // trigger first render
  applyTheme();
  $('#versionBadge').textContent = store.data.version;
  renderSettings();
  // select default chip 6M
  publish();
})();
// ---------- Interactive Chart Modal ----------
let chartSeriesFull = [];
let viewStartIdx = 0;
let viewEndIdx = 0;

function openChartModal() {
  // Initialize modal controls, then show the dialog and render the chart.  Rendering after setting
  // display ensures the canvas has a width and height.  Without this order, the
  // chart may appear blank until resized.
  initModalControls();
  $('#chartDlg').style.display = 'flex';
  // Defer rendering slightly to allow layout to update
  setTimeout(() => {
    updateModalChart();
  }, 0);
}

function closeChartModal() { $('#chartDlg').style.display = 'none'; }

$('#chart').addEventListener('click', openChartModal);
$('#chartDlgClose').addEventListener('click', closeChartModal);

function updateRangeLabel(){
  const s = chartSeriesFull[viewStartIdx];
  const e = chartSeriesFull[viewEndIdx];
  if(!s || !e) return;
  const fmtD = (d)=> d.toISOString().slice(0,10);
  $('#chRangeLabel').textContent = fmtD(s.x) + ' ‚Üí ' + fmtD(e.x);
}

// Initialize the modal controls based on the current overview state.  This
// function copies the target date and active range chip from the overview
// into the modal controls so that the chart reflects the same horizon.  If
// no chip is active in the main overview, the modal chips will be cleared
// and the date field used as is.
function initModalControls() {
  // copy date from main target date or default to today
  const mainDate = $('#targetDate').value || todayStr();
  $('#modalTargetDate').value = mainDate;
  // replicate active chip state
  const mainActive = document.querySelector('#overview .chip.active');
  // reset modal chips
  document.querySelectorAll('#modalChips .chip').forEach(ch => ch.classList.remove('active'));
  if(mainActive) {
    const range = mainActive.getAttribute('data-range');
    document.querySelectorAll('#modalChips .chip').forEach(ch => {
      if(ch.getAttribute('data-range') === range) ch.classList.add('active');
    });
  }
}

// Compute series and balance for the modal based on the selected target date.  This
// function updates the global chartSeriesFull and resets the view window.  It
// also updates the estimated balance display and range label.
function updateModalChart() {
  const dateStr = $('#modalTargetDate').value || todayStr();
  const to = new Date(dateStr);
  const {series, endBalance} = simulateBalance(to);
  chartSeriesFull = series;
  if(chartSeriesFull.length < 2) {
    toast('Not enough data to display');
    return;
  }
  viewStartIdx = 0;
  viewEndIdx = chartSeriesFull.length - 1;
  $('#modalEstBalance').textContent = fmt(endBalance);
  drawInteractive();
  updateRangeLabel();
}

// Attach event handlers for the modal controls.  Runs once on script load.
(function attachModalHandlers(){
  document.addEventListener('DOMContentLoaded', () => {
    const modalDate = document.getElementById('modalTargetDate');
    if(modalDate) {
      modalDate.addEventListener('change', () => {
        document.querySelectorAll('#modalChips .chip').forEach(ch => ch.classList.remove('active'));
        updateModalChart();
      });
    }
    // Chip click
    document.querySelectorAll('#modalChips .chip').forEach(ch => {
      ch.addEventListener('click', () => {
        document.querySelectorAll('#modalChips .chip').forEach(c => c.classList.remove('active'));
        ch.classList.add('active');
        const range = Number(ch.getAttribute('data-range') || 180);
        const to = addDays(new Date(), range);
        document.getElementById('modalTargetDate').value = to.toISOString().slice(0,10);
        updateModalChart();
      });
    });
  });
})();

function clampIdx(i){ return Math.max(0, Math.min(i, chartSeriesFull.length-1)); }

function currentWindow(){
  return chartSeriesFull.slice(viewStartIdx, viewEndIdx+1);
}

function zoom(factor){
  // factor >1 zooms in (narrower window), <1 zooms out (wider window)
  const len = viewEndIdx - viewStartIdx + 1;
  // avoid zooming in too far (keep at least 5 points visible)
  if(len <= 5 && factor > 1) return;
  const center = Math.floor((viewStartIdx + viewEndIdx) / 2);
  let newHalf = Math.max(3, Math.floor(len / (2 * factor)));
  viewStartIdx = clampIdx(center - newHalf);
  viewEndIdx   = clampIdx(center + newHalf);
  drawInteractive();
  updateRangeLabel();
}

function pan(steps){
  // steps positive to pan right, negative to pan left.  Pan by a fraction of
  // the current window size for smoother navigation.
  const windowSize = viewEndIdx - viewStartIdx + 1;
  const shift = steps * Math.max(1, Math.floor(windowSize * 0.25));
  let newStart = viewStartIdx + shift;
  let newEnd   = viewEndIdx + shift;
  // clamp to boundaries and maintain window size
  if(newStart < 0) {
    newStart = 0;
    newEnd = newStart + windowSize - 1;
  }
  if(newEnd > chartSeriesFull.length - 1) {
    newEnd = chartSeriesFull.length - 1;
    newStart = newEnd - (windowSize - 1);
    if(newStart < 0) newStart = 0;
  }
  viewStartIdx = newStart;
  viewEndIdx   = newEnd;
  drawInteractive();
  updateRangeLabel();
}

// Attach chart control handlers only if the respective elements exist
const zoomInBtn = $('#chZoomIn');
if (zoomInBtn) zoomInBtn.addEventListener('click', ()=>zoom(1.5));
const zoomOutBtn = $('#chZoomOut');
if (zoomOutBtn) zoomOutBtn.addEventListener('click', ()=>zoom(1/1.5));
const panLeftBtn = $('#chPanLeft');
if (panLeftBtn) panLeftBtn.addEventListener('click', ()=>pan(-1));
const panRightBtn = $('#chPanRight');
if (panRightBtn) panRightBtn.addEventListener('click', ()=>pan(1));
const resetBtn = $('#chReset');
if (resetBtn) resetBtn.addEventListener('click', ()=>{
  viewStartIdx = 0;
  viewEndIdx   = chartSeriesFull.length - 1;
  drawInteractive();
  updateRangeLabel();
});
const exportBtn = $('#chExport');
if (exportBtn) exportBtn.addEventListener('click', ()=>{
  // export a clean version of the current chart with a light background and date range
  const winSeries = currentWindow();
  const rangeTitle = document.getElementById('chRangeLabel').textContent || '';
  const canvasWidth = document.getElementById('chartInteractive').clientWidth;
  const canvasHeight = document.getElementById('chartInteractive').clientHeight + 40;
  const exportCanvas = document.createElement('canvas');
  exportCanvas.width = canvasWidth;
  exportCanvas.height = canvasHeight;
  drawChartOn(exportCanvas, winSeries, { title: rangeTitle });
  const url = exportCanvas.toDataURL('image/png');
  const a = document.createElement('a');
  a.href = url;
  a.download = 'balance_chart.png';
  a.click();
});

function drawInteractive(){
  const canvas = $('#chartInteractive');
  const ctx = canvas.getContext('2d');
  const series = currentWindow();
  const dpr = window.devicePixelRatio || 1;
  const width = canvas.clientWidth;
  const height = canvas.clientHeight || 480;
  canvas.width = Math.floor(width * dpr);
  canvas.height = Math.floor(height * dpr);
  ctx.scale(dpr, dpr);
  ctx.clearRect(0,0,width,height);
  if(series.length<2) return;
  const xs = series.map(p=>p.x.getTime());
  const ys = series.map(p=>p.y);
  const minX = Math.min(...xs), maxX = Math.max(...xs);
  const minY = Math.min(...ys), maxY = Math.max(...ys);
  const dx = (maxX-minX)||1, dy=(maxY-minY)||1;
  const padX=48, padY=28;
  const computed = getComputedStyle(document.documentElement);
  const lineColor = (computed.getPropertyValue('--accent-2')||'#3b82f6').trim();
  const axisColor = (computed.getPropertyValue('--muted')||'#9ca3af').trim();
  const textColor = (computed.getPropertyValue('--text')||'#e5e7eb').trim();
  // axes
  ctx.strokeStyle = axisColor; ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(padX, padY); ctx.lineTo(padX, height-padY); ctx.lineTo(width-padX, height-padY); ctx.stroke();
  // ticks (y)
  ctx.fillStyle = textColor; ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto';
  const yTicks = 4;
  for(let i=0;i<=yTicks;i++){
    const val = minY + (i*(dy/yTicks));
    const y = height - padY - (i*(height-2*padY)/yTicks);
    ctx.fillText(fmt(val), 6, y+4);
    ctx.beginPath(); ctx.moveTo(padX, y); ctx.lineTo(width-padX, y); ctx.strokeStyle='rgba(255,255,255,0.06)'; ctx.stroke();
  }
  // zero line
  if(minY<0 && maxY>0){
    const zy = height - padY - ((0-minY)/dy)*(height-2*padY);
    ctx.beginPath(); ctx.moveTo(padX, zy); ctx.lineTo(width-padX, zy); ctx.setLineDash([4,4]); ctx.strokeStyle=axisColor; ctx.stroke(); ctx.setLineDash([]);
  }
  // line
  ctx.strokeStyle = lineColor; ctx.lineWidth=2; ctx.beginPath();
  series.forEach((pt, i)=>{
    const x = padX + ((pt.x.getTime()-minX)/dx)*(width-2*padX);
    const y = height - padY - ((pt.y-minY)/dy)*(height-2*padY);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }); ctx.stroke();

  // store scales for hover
  canvas._chartScale = { minX, maxX, minY, maxY, padX, padY, width, height, series };
}

/**
 * Draw a static chart onto the provided canvas using a light theme.  This
 * helper is used for PNG export so that the downloaded image is readable
 * regardless of the site's dark mode.  It renders a title (date range)
 * above the chart area.  The chart is drawn with black axes, grey grid
 * lines and a blue line for the balance series.
 * @param {HTMLCanvasElement} canvas The canvas to draw on
 * @param {Array<{x: Date, y: number}>} series The data series to render
 * @param {Object} opts Additional options: { title: string }
 */
function drawChartOn(canvas, series, opts = {}) {
  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;
  // clear & white background
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, width, height);
  const title = opts.title || '';
  // Title area height
  const topMargin = 30;
  ctx.fillStyle = '#111827';
  ctx.font = 'bold 16px system-ui, -apple-system, Segoe UI, Roboto';
  if(title) {
    ctx.fillText(title, 10, 20);
  }
  if(!series || series.length < 2) return;
  // compute ranges
  const xs = series.map(p => p.x.getTime());
  const ys = series.map(p => p.y);
  const minX = Math.min(...xs);
  const maxX = Math.max(...xs);
  const minY = Math.min(...ys);
  const maxY = Math.max(...ys);
  const dx = (maxX - minX) || 1;
  const dy = (maxY - minY) || 1;
  // chart area padding
  const padX = 48;
  const padY = 40;
  const chartTop = topMargin;
  const chartHeight = height - chartTop - padY;
  const chartBottom = chartTop + chartHeight;
  // axes
  ctx.strokeStyle = '#333333';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(padX, chartTop);
  ctx.lineTo(padX, chartBottom);
  ctx.lineTo(width - padX, chartBottom);
  ctx.stroke();
  // y ticks
  ctx.fillStyle = '#333333';
  ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto';
  const yTicks = 4;
  for(let i = 0; i <= yTicks; i++) {
    const val = minY + (i * dy / yTicks);
    const y = chartBottom - (i * chartHeight / yTicks);
    ctx.fillText(fmt(val), 4, y + 4);
    ctx.beginPath();
    ctx.moveTo(padX, y);
    ctx.lineTo(width - padX, y);
    ctx.strokeStyle = '#e5e7eb';
    ctx.stroke();
  }
  // zero line
  if(minY < 0 && maxY > 0) {
    const zy = chartBottom - ((0 - minY) / dy) * chartHeight;
    ctx.beginPath();
    ctx.moveTo(padX, zy);
    ctx.lineTo(width - padX, zy);
    ctx.setLineDash([4, 4]);
    ctx.strokeStyle = '#666666';
    ctx.stroke();
    ctx.setLineDash([]);
  }
  // line
  ctx.strokeStyle = '#3b82f6';
  ctx.lineWidth = 2;
  ctx.beginPath();
  series.forEach((pt, i) => {
    const x = padX + ((pt.x.getTime() - minX) / dx) * (width - 2 * padX);
    const y = chartBottom - ((pt.y - minY) / dy) * chartHeight;
    if(i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  });
  ctx.stroke();
}

function canvasXYToData(canvas, evt){
  const rect = canvas.getBoundingClientRect();
  const x = evt.clientX - rect.left;
  const y = evt.clientY - rect.top;
  return {x,y};
}

function onChartHover(evt){
  const canvas = $('#chartInteractive');
  const tip = $('#chartTip');
  const sc = canvas._chartScale;
  if(!sc) return;
  const pos = canvasXYToData(canvas, evt);
  const {minX, maxX, minY, maxY, padX, padY, width, height, series} = sc;
  if(pos.x < padX || pos.x > width - padX || pos.y < padY || pos.y > height - padY){
    tip.style.display='none'; canvas.style.cursor='default'; return;
  }
  canvas.style.cursor='crosshair';
  const rel = (pos.x - padX) / (width - 2*padX);
  const time = minX + rel * (maxX - minX);
  // find nearest index
  let nearest = 0, best = Infinity;
  for(let i=0;i<series.length;i++){
    const d = Math.abs(series[i].x.getTime()-time);
    if(d<best){ best=d; nearest=i; }
  }
  const pt = series[nearest];
  const px = padX + ((pt.x.getTime()-minX)/(maxX-minX||1))*(width-2*padX);
  const py = height - padY - ((pt.y-minY)/(maxY-minY||1))*(height-2*padY);
  // redraw to add crosshair without accumulating
  drawInteractive();
  const ctx = canvas.getContext('2d');
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,0.25)'; ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(px, padY); ctx.lineTo(px, height-padY); ctx.moveTo(padX, py); ctx.lineTo(width-padX, py); ctx.stroke();
  ctx.restore();
  // tooltip
  //
  tip.style.display='block';
  tip.textContent = pt.x.toISOString().slice(0,10) + ' ‚Ä¢ ' + fmt(pt.y);
  let left = px + 10;
  let top = py - 10;
  // keep inside
  const wrap = canvas.parentElement.getBoundingClientRect();
  if(left + 160 > wrap.width) left = px - 170;
  if(top < 0) top = py + 20;
  tip.style.transform = 'translate(0,0)';
  tip.style.left = Math.round(left) + 'px';
  tip.style.top = Math.round(top) + 'px';
}

function onChartLeave(){
  $('#chartTip').style.display='none';
  drawInteractive();
}

$('#chartInteractive').addEventListener('mousemove', onChartHover);
$('#chartInteractive').addEventListener('mouseleave', onChartLeave);


document.getElementById('chartDlg').addEventListener('transitionend', function(e) {
  if (e.propertyName === 'display' || e.propertyName === 'opacity') {
    if (document.getElementById('chartDlg').style.display === 'flex') {
      if (typeof drawInteractive === 'function') {
        drawInteractive();
        if (typeof updateRangeLabel === 'function') updateRangeLabel();
      }
    }
  }
});

</script>
</body>
</html>
